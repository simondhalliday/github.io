---
title: "CVC Workshop Notes"
author: "Simon Halliday"
date: "2015-July -13"
output: 
  html_document:
    css: ../stylesheets/styles.css

---

## Introduction to R and R studio
Scatterplot with birth data:
```{r, message = FALSE}
require(mosaic)
require(mosaicData)
xyplot(births ~ dayofyear, data = Births78)

```


Other commands we've run during the workshop day 1 and some comments on them. 
```{r}
histogram(~ age, data = HELPrct) #histogram of age
favstats(~ age, data = HELPrct) #My favorite statistics; it ignores NAs
tally(~sex, data = HELPrct) #Count of gender
tally(~sex, format = "percent", data = HELPrct) #Percents of gender
tally(~sex, format = "proportion", data = HELPrct) #Proportions of gender
tally(~substance, data = HELPrct) #Count of substance
tally(~substance, format = "perc", data = HELPrct) #Percents of substance
tally(sex ~ substance, data = HELPrct) #Cross-tab sex & substance
tally(~ sex + substance, data = HELPrct) #Ditto, just a different format
```

Also, always remember the `mplot` command for producing graphs and clicking on the 'Show Expression'. 

## Data Structures and Tidy Data

Consider cases and variables

* a __row__ is always a __case__
* a __column__ is always a __variable__ 

In tidy data: 

* No units
* No footnotes

All of this goes into a codebook only. 




## Visualizing Data

DTK:
* Glyphs are marks; data glyps are also marks and the features of the glyphs encode the values of the variables & the visual properties are aesthetics. The choices that we make as experts in our field is the choice of aesthetic to map to variables. The word 'aesthetic' here is taken from its early 
*When we make data glyps we map variables to aesthetics. 
*A scale is for a computer and a guide is for a person (about the aesthetics). A legend (beside a graph) is an example of a guide. 
*A data table is glyph-ready when there is one row for each glyp to be drawn (I could say, "that's x-position, that's y-position, that's color, that's size." 
* Glyph-ready data are tidy data, but tidy data are not necessarily glyph-ready.
*Sometimes glyphs represent the collective properties of variables, e.g. in the case of histograms. 

RP: 

* Teaches going from the histogram back to the data, rather than going from the data to the histogram because of having had the experience of studnets rote learning to go from data to a histogram without actually understanding what histograms mean. 

```{r, message = FALSE}
require(lubridate)
data(Births78)
head(Births78, 3)
```

* We want to generate a plot using `ggplot() + geom_point()`
* We also need aesthetics, `aes()`, e.g. `aes(x = date, y = births)`
* And a call on the data, data = Births78

```{r}
ggplot(data = Births78, aes(x = date, y = births)) + geom_point()
```
But, we need to add days of the week because that's more useful to us: 
```{r}
Births78 <- 
  Births78 %>% 
  mutate(wday = wday(date, label = TRUE))
  ggplot(data = Births78, aes(x = date, y = births, color = wday)) + geom_point() 
```
Note, that the same graph would be generated by the following: 
```{r}
  ggplot(data = Births78) + geom_point(aes(x = date, y = births, color = wday)) 
```

We could change this to a line graph: 
```{r}
 ggplot(data = Births78) + geom_line(aes(x = date, y = births, color = wday)) 
```

Or we could have points and lines; note that we have _moved_ the `aes` commands into the `ggplot` command because it applies to _all_ the layers. 
```{r}
 ggplot(data = Births78, aes(x = date, y = births, color = wday)) + geom_line() + geom_point()
```
We could have put the data outside the ggplot command using the magrittr pipe: 
```{r}
 Births78 %>%
  ggplot(aes(x = date, y = births, color = wday)) + geom_line() + geom_point()
```

We need to do setting rather than mapping for things like colors; inside the individual geom you __set__ the color you want (*different to ggvis* where setting is done with `:=`). Within ggplot you can _only_ __map__ nor __set__. 
```{r}
 Births78 %>%
  ggplot(aes(x = date, y = births)) + geom_point(color = "navy")
```

Combine the colored lines with navy points - notice that `wday` is in the  `aes` in the `geom_line` whereas with `geom_point` we don't call on `aes` because we're simply setting (not mapping).
```{r}
 Births78 %>%
  ggplot(aes(x = date, y = births)) + 
    geom_line(aes(color = wday)) + 
    geom_point(color = "navy")
```
Recall that we can check out the kinds of geoms that exist if we use the command `apropos`, notice the use of the caret (`^`)
```{r}
apropos("^geom")
```

* Key plot metric: Does my plot make the comparisions I am
interested in __easily__ and __accurately__. 

* We can generate a new geom, a `geom_bar`: 

```{r}
HELPrct %>% 
ggplot(aes(x = substance)) + 
geom_bar()
```
Notice that we were able to construct the bar chart even though our data weren't glyph-ready with counts; ggplot did it for us. 

* We want to generate histograms where we can __set__ the binwidth:

```{r}
HELPrct %>% 
    ggplot(aes(x = age)) + 
    geom_histogram(binwidth = 2)
```
* We also often want to use frequency polygons or kernel density functions:

```{r}
HELPrct %>% 
ggplot(aes(x = age)) + 
    geom_freqpoly(binwidth = 2)
```

```{r}
HELPrct %>% 
ggplot(aes(x = age)) + 
    geom_density()
```

But, note RP prefers to add density to a line plot because it look
```{r}
HELPrct %>% 
ggplot(aes(x = age)) + 
geom_line(stat = "density")
```

Or we could have put the geom in the stat_density

```{r}
HELPrct %>%
ggplot(aes(x=age)) +
stat_density( geom="line")
```

Now generate your own graph looking at the average consumption of graphs (which I did by groups)
```{r}
HELPrct %>% 
    ggplot(aes(x = i1)) + 
    geom_line(stat = "density", aes(color = factor(substance)))
```



##Data Wrangling

* We want to break the data wrangling up into small steps with simple rules to deal with simple 'chunks' at each point. 
* We shall start with a sub-set of commands that are most useful and ignore much of the many things we often use when learning R (if you have familiarity), e.g. we'll ignore `$, [], [[]], `

There are 5 kinds  of things (objects) in R:

1. data tables (aka dataframes), our convention is for first letter upper-case, e.g. `BabyNames`
2. variables, i.e. the stuff in the tables,our convention is for first letter lower-case, e.g. `year`
3. scalars, e.g. `"Treatment"` or `42` (thanks DA)
4. functions & their arguments: e.g. positional arguments, named arguments (parentheses follow names of things if and only if those things are functions, e.g. `sd()`; multiple arguments separated with commas)
5. pipes: arrange sequences, `%>%` takes something and puts it as the/an input to a function, e.g. `something >%> function()` rather than `function(something, other stuff, ...)`.

3 Main kinds of functions for Wrangling

1. __Data verb__ takes a data table as input, does something & gives a data table as output
2. __Transformation function__ takes a variable and transforms it in some way; takes a variable as input and produces a variable as output (a la Sraffa?)
3. __Reduction function__ takes a bunch of variables and turns them into a single variable, e.g. the mean, max, standard deviation, etc

To run the following you may need to install the packages `NHANES`, `dplyr`, and `babynames`. Run the command, e.g. `install.packages("NHANES")`. Remember to require these packages.

Now we run some commands to start wrangling the data. 

```{r, message = FALSE}
require(NHANES)
require(dplyr)
require(babynames)
NHANESmajors <- filter(NHANES, Age >= 21)
nowsmoking <- select(NHANES, Age, SmokeNow)
nowsmoking %>% 
  head()
group_by(babynames, name, year)  
head(KidsFeet)
select(KidsFeet, birthyear, domhand) %>% 
  head()
righties <- filter(KidsFeet, domhand == "R")
head(righties)

```

The pipe (`%>%`)  makes it clear what the individual lines are doing. 

```{r}
KidsFeetArea <- KidsFeet %>% 
  mutate(area = length * width) %>% 
  head()
```

`arrange` orders your cases in terms of the variable you select in __ascending__ order, e.g. `arrange(area)`.
```{r}
KidsFeet %>% 
  mutate(area = length * width) %>% 
  arrange(area) %>% 
  head()
```

To arrange in __descending__ order, you can add `desc()` within arrange. 
```{r}
KidsFeet %>% 
  mutate(area = length * width) %>% 
  arrange(desc(area)) %>% 
  head()
```

We can also add another argument to arrange to break ties, e.g. adding birthmonth (I'm going to head for 10 cases): 
```{r}
KidsFeet %>% 
  mutate(area = length * width) %>% 
  arrange(area, desc(birthmonth)) %>% 
  head(10)
```

The Verb `summarise` creates a row with summary statistics that you select by defining them in functions with particular labels. 
```{r}
NewThing <- KidsFeet %>% 
  mutate(area = length * width)
AnotherNewThing <- NewThing %>% 
  summarise(ave_area = mean(area))
head(NewThing)
head(AnotherNewThing)
```
The important feature of `summarise` is that it'll create one row with a variety of variables that you specify, i.e. other means, say the max of the variable, e.g. 
```{r}
AnotherNewThing <- NewThing %>% 
  summarise(ave_area = mean(area), max_area = max(area))
AnotherNewThing
```

We have looked at 5 commands so far: 

1. `filter`
2. `select`
3. `mutate`
4. `arrange`
5. `summarise`

We shall add another, more complex command,  `group_by`. 

Let us 
```{r}
NewThing %>% 
  group_by(sex) %>%
  summarise(ave_area = mean(area), max_area = max(area))
```
Or we could just use KidsFeet rather than assigning things to dataframes like we did with `NewThing`.
```{r}
KidsFeet %>% 
  mutate(area = length * width) %>% 
  group_by(sex) %>%
  summarise(ave_area = mean(area), max_area = max(area))
```

Or we could arrange by both dominant hand and birth year: 
```{r}
KidsFeet %>% 
  mutate(area = length * width) %>% 
  group_by(domhand, birthyear) %>%
  summarise(ave_area = mean(area), max_area = max(area))
```

It's important to remain aware of the change in the __cases__ when you use group_by. 
1. You have changed the cases from the cases _before_ `group_by`, e.g. the kids, and then you create a new case, e.g. a group of kids. 
2. Not all the variables in the original data will appear in the output of `group_by`, the ones you group by and the ones you create will be there. 


```{r}
NHANES %>% favstats(BMI ~ Gender, data = .) #This works because I tell it to be put where the period is
mean(BMI ~ Gender, na.rm = TRUE, data = NHANES) #We have to tell it to ignore NAs
favstats(BMI ~ Gender, data = NHANES) #Ignores NAs
NHANES %>% 
  group_by(Gender) %>%
  summarise(mean_bmi = mean(BMI, na.rm= TRUE), count = n())
```

What happens if we only want to look at 20-year-olds?
```{r}
NHANES %>% 
  filter(Age == 20) %>%
  group_by(Gender) %>%
  summarise(mean_bmi = mean(BMI, na.rm= TRUE), count = n())
```


###Data Wrangling Cont. (Weds Morning)

Some functions we used:
*Sample_n() takes a random sample, like we did with the Babynames with NH.

*What about functions that take two tables as input and produce one table as output? 
*We often think about this as joining or merging data, and we can use a variety of commands to do this. 
*But we should keep this separate from the idea of __concatenation__, which adds rows to an already existing data table. 


Joining data 
* __Inner Join__ Take the cases from the __left__ data table (what I would think of as the 'Master Data' from Stata) and join it to the cases on the __right__ data (what I would think of as the 'merging data')

By default, it looks for a variable and uses that as the default. 
BB recommends that we __always__ use the `by` condition. 

[ME: Is there a way to generate unique identifiers algorithmically? That is, the thing I spent most of my time on was generating unique identifiers that worked because I have experience generating unique IDs.]

```{r}
grades <- read.csv("http://tiny.cc/mosaic/grades.csv",
                   stringsAsFactors = FALSE)
courses <- read.csv("http://tiny.cc/mosaic/courses.csv",
                    stringsAsFactors = FALSE)
grade_to_number <- read.csv("http://tiny.cc/mosaic/grade-to-number.csv",
                            stringsAsFactors = FALSE)
```


We could join these if we wanted to. 

##Randy - how to `gather` data
Randy's notes are [here](http://dtkaplan.github.io/CVC/Summer2015/Learn/TidyData/TidyGapMinder.htm).


We want:
*a column that says country
*a column that says year, and
*a colum that has the proportion of HIV

We want to re-shape data (as with `reshape` in Stata).

We therefore need a way to convert data from wide into long (or long into wide)

To go from wide to narrow (long) we 

```{r}
HIVdata <- read.csv("http://dtkaplan.github.io/CVC/Summer2015/Learn/TidyData/HIV.csv", stringsAsFactors = FALSE)
head(HIVdata)
```

We need to alter this to get rid of the terrible initial name: 
```{r}
HIVdata2 <- 
  HIVdata %>% 
  select(country = starts_with("Estimated"), starts_with("X"))
#select lets you rename a variable, as we have done here with country = and called the thing starting with "Estimated" to country
head(HIVdata2, 3)
```

We need to tell R the data table to work with.
We need to tell R which variables get __repeated__ and which get `tipped' from wide to long. Computer scientists call these key-value pairs. 

```{r}
require(tidyr)
HIVdata3 <-
  HIVdata2 %>% gather( year, HIV.perc, -country)
head(HIVdata3, 3)
```
notice that we have a `-` sign in front of the country because we want top tip everything __except__ the country column. 

But we still need to remove the X from the years; to do that we use the command `extract_numeric()` which is a transformation function. 

```{r}
HIVdata4 <-
  HIVdata3 %>% mutate( year = extract_numeric(year))
head(HIVdata4, 3)
```

We want to graph the data now: 
```{r}
HIVdata4 %>%
  filter(country %in% c("South Africa", "Kenya", "Uganda", "Botswana","Malawi", "Tanzania", "United States")) %>%
  #Notice here that we only do data from 198 onwards
  filter(year > 1988) %>%
  ggplot(aes(x = year, y = HIV.perc, color = country)) +
  geom_line(size=2, alpha=0.5) 
```



##Importing Data
###Importing a .csv
You can import data either with a csv or with a url of a csv. For example, we could import:
http://dtkaplan.github.io/CVC/Summer2015/Learn/Wrangling/Activity.csv
To remove an object (rather than using the broom icon to sweep them away), you can type `rm(ObjectName)` e.g. rm(Activity). 

### Importing from Excel
We need to use the package `readxl`. 
```{r, message =  FALSE}
require(readxl)
Gender <- read_excel("Gender.xls", skip = 2)
#glimpse(Gender[, 1:10])
head(Gender, 3)
```
 
We also need to be able to save objects like Gender to an Rdata file. 
`save(Gender, file = "Gender.Rdata")`. I didn't put this in a chunk because I didn't want to have R run this command. 

A function `saverds()` can only save one object, saves it in an unnamed form, but you name it when you load it. 


##Teaching Tips
These are tips I picked out (thus idiosyncratic):

* __For teaching the idea of the command line and the script:__ How many of you had a [TI calculator](https://en.wikipedia.org/wiki/Comparison_of_Texas_Instruments_graphing_calculators)? (TI = Texas Instruments; I did not know this abbreviation -- like the international students) Did you know how to use it on the very first day? What about on your final day of high school? (RP)
* When R outputs the error `object '[object name]' not found` that normally means you (or your student) have mis-spelt the variable name or dataframe name. (RP)
* Pick your favorite way (command) for doing a job, don't show students too many methods. You'll overwhelm them if you give them too much. __Less volume, more creativity__. (RP)
* Call tildes `~` 'wiggles'! Sounds funny and is less scary then tilde. (RP) 
* Two most important questions: What do you want R to do? (goal) What must R know to do that? (RP) [me - why don't I call R a specific name? e.g. R = Rachel - What do I want Rachel to do? What must Rachel know to do that?]
* Don't teach them all the bells & whistles in a lecture when _you_ want it. Rather, do it when they ask. (RP)
* Get students to adopt a __workflow__ such that students can reproduce their work again with new data. (NH) 
* When you start a new Markdown file (Rmd), it means that you need to load each package in the Rmd file. (NH) Often it's useful to do so with the message include = FALSE to suppress the inclusion of that code in the output file. 
* Students struggle to understand the ecological paradox (DTK). (relates to the [fallacy of division](https://en.wikipedia.org/wiki/Fallacy_of_division); which is the complement of the [fallacy of composition](https://en.wikipedia.org/wiki/Fallacy_of_composition)).
* To explain the magrittr pipe -- which we should read it as 'then' or 'and then' (taking the advice of Hadley and Garrett G). Or, we can talk about actual plumbing and piping: put some water (or a data table) in one end and send it out another. 


## Commonplace Book

* RP: "If your students find R to be the hardest part of your course, your R is too hard and your questions are too easy."
* RP: "You need to learn to see before you can see to learn." (As advice to professors to get them over the problem of assumed prior learning)



```{r}
require(mosaic)
require(mosaicData)
HELPrct %>%
  ggplot(aes(x = i1, color = substance, linetype = sex)) +
  geom_line(stat = "density")

HELPrct %>% 
ggplot(aes(x = i1, color = substance)) + 
  geom_line(stat = "density") +
  facet_grid(. ~sex) #the period means don't facet any of the 'y', but be sure to facet ont he x variable for sex;

HELPrct %>% 
ggplot(aes(x = age, color = substance, linetype = sex)) + 
geom_line(stat = "density")

HELPrct %>% 
ggplot(aes(x = age, color = substance)) + 
  geom_line(stat = "density", size = 1) + #NB: not here size is outside the aes and simpy put in geom_line to be set rather than mapped
  facet_grid(. ~sex)
  
```

If you want to have many, many facets, then you can use the command `facet_wrap` which will just create a facet for every single one. 


Put things next to each other is called dodging: 
```{r dodging}
HELPrct %>%
ggplot(aes(x = substance, y = age, color = sex)) + 
  geom_boxplot(position = position_dodge(width = 1)) 
```

```{r pregnancy}
require(NHANES)
NHANES %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_density2d() +
  facet_grid(Gender ~ PregnantNow)
  
```

These plots with the hexes basically show different colours when there are more observations:
```{r hex_plot}
require(hexbin)
NHANES %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_hex() +
  facet_grid(Gender ~ PregnantNow)
```


```{r}

```

